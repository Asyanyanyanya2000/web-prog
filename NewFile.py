
# ghjdthrf nhteujkmybrf jn 3 cnjhjy
'''
class TrCh:
    def __init__(self,sides):
        self.sides = sides
    
    def is_tr(self):
        if all(isinstance(side,(int,float)) for side in self.sides):
            if all(side > 0 for side in self.sides):
                sort_s=sorted(self.sides)
                if sort_s[0]+sort_s[1]>sort_s[2]:
                    return 'можно'
                return "жаль, не выйдет"
            return "c отрицательными числами ничего не выйдет"
        return 'вводите только числа'

triang1= TrCh([2,3,4])
triang2= TrCh([-2,3,4])
triang3= TrCh(["2",3,4])
print (triang1.is_tr())
'''

'''
class Ni:
    def __init__(self,name,age):
        if name=='Николай':
            self.name=name
        else:
            self.name= f"no, {name} is NIk"
        self.age=age

u1= Ni("ynj",13)
print(u1.name)
'''

#ыыыыыы 18 апр 25

# 11 паттерны проектирования (шаблоны) набор инструментов 
'''
литература -
эрик гамма 
ричард хелм 
ральф ждонсон 
джон влисидас 
"паттерны проектирования" 
(в основном ждава и с++, но для всех ок)

паттерн это общее многократное использование решение проблемы которое часто встречается внутри конкретной стиуации 

аналогия - готовый чертеж

нельзя применять как функции из инпортированной библиотеки 
паттерн это не участок кода - это концепция решения повторяющиейся проблемы 


классификация паттернов проектирования :
изначально их было 2 - по проблеме которую решает или по классу 
но разделилось на более утвержденные 
3;
1) пораждающие патторны - возможность создания контролируемым образом инициализации и конфигурации объектов классов и типов данных на основе требуемых критериев 
2) структурные паттерны - они позволяют огранизовать структуры связанных объектов и классов предоставляяя функциональные возможности 
3) поведенчиские паттерныы - направлены на выявление общих моделей взаимодействия меж объектами 
'''
'''
синглтон (одиночка ) - цель которого ограничить возможность создания об класса 1 экземпляром. он обеспеецивет глобальность до 1 экземпляра и глобальный доступ к созданому объекту 
пример Ж 1 экземпляр доступный для всех объектов или если необходим более строгий контроль над глобаьными переменными 
основные особенности: 
1- класс имеет только 1 экземпляр 
2- получение глобальной точки доступа к экземпляру 
3- синглтон инициируется только при первом запросе 
4- маскирует плохой дизайн до определенного момента (считается антипатернном) 



дикоратор 
- это структурный паттерню. цель предостовленние новых классов и возможностей во время выполнения кодаю 
чаще всего представляет абстрактый класс принимающий в конструкторе объект функциональность которого мы хотм расширить 
однако в питоне есть втроенный миханизм дикоратора который можно использовать 
случаи использования: 
1- необходимость назначить доп обязоаности объектам во время выполнения не ломая код который используюбт это объекты 
2- по каким либо причинам невозможно расширить возможности объекта через наследование 
основные возможности декоратора:
1- расширение поведения объекта без создания подкласса 
2- добавление или удовение обязаностей объекта во время выполнения 
3- объединение нескольких моделей поведения путем применения к объекту нескольких декораторов 
4- разделение монолитного класса который реализует множестово вариантов поведения на более мелкие классы 
при приминении этого патрена возникают следующие сложности 
1- применен одной конкретной обертки ( раппер) из центра стека 
2- реализация декоратора при исключении его зависимости от порядка в котором обертки уложены в стек 



итератор 
итератор это поведенчиский паттерн его цель позволить вам обходить эл колллекции не раскрывая ее базовое предстовление 
для того что бы реализовать итер в питон есть 2 варианта 
1- реализовать в классе спец методы __iter__ __next__ 
2- использовать генераторы(??)
примеры использования : 
1- коллекция имеет сложную структуру. необходимо скрыть ее от клиента из соображений удобства и безопасности 
2- требуется сократить дублирование обходного кода по всему приложению 
3- обход элементов различных структур данных 
4- изначально незветны детали структур данных 
возможности итератора
1- отчистка клиенского кода и коллекций путем вынесения кода в обход отдельные классы 
2- реализовать новые типы коллеций и итераторов с передачей их в существующий код без нарушений 
3- обходить одну и ту же коллецию с помощью нескольких итераторов паралельно учитывая что каждую из них хранит информацию о сотоянии итерации 
4- возможность отложить итерацию и продолжить ее по мере необходимости 
испоользование этого паттерна лишшнее если используются простые коолекции 
'''

#дают задачу на класс (наследование полиморфизм инкапсуляция) 
''' создайте класс BankAccount с приватныи =м атрибутом balance 
реализуйте методы для депозита, снятия и проверки баланса (наследование полиморфизм инкапсуляция) 
используйте методы доступа для работы с приватным атрибутом 
'''
#cthutq cghfdbkcz c lfpfxtq yf rkfcc $)
# tot rfre.nj pflfxe crbyekb cthjve d kc d nu 





#21 апр 25, гипотетицки это все еще 11 тема
'''
class Car:
    def __init__(self,brand, model, year):
        self.brand=brand
        self.model =model
        self.year =year

ccarr=Car('a','b','c')

print(ccarr.brand, ccarr.model, ccarr.year)
'''

#вывод таблицы умножения
'''
i=0
while i<10:
    i+=1
    j=0
    while j<10:
        j+=1
        if j==10:
            print(j*i)
        else:
            print(j*i, end=" ")
'''

